%{
// Includes the definition of symbolic tokens. The enum definition in this
// header file replaces the `enum Token {...}` you wrote in project 1.
// It also includes the declaration of the global variable `yylval` which will
// be used by code generated by Yacc/Bison.
//
// This header file is generated by Yacc/Bison from parser.y. We suggest that
// you take a look at the content of this header file - it's not long.
#include "y.tab.h"

#include <stdio.h>
#include <stdlib.h>
extern int yylex();

void syntax_error() {
    fprintf(stderr, "Syntax errors in %d\n", yylineno);
    exit(EXIT_FAILURE);
}

%}

%option yylineno
/* %option noyywrap */

%%

[ \t\r\n]*            { } /* skip whitespace */
"//".*                { } /* inline comments */
\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/ { } /* block comments */

boolean               { return KW_BOOLEAN;         } /* keywords */
class                 { return KW_CLASS;           }
false                 { return KW_FALSE;           }
true                  { return KW_TRUE;            }
int                   { return KW_INT;             }
main                  { return MAIN;               }
public                { return KW_PUBLIC;          }
static                { return KW_STATIC;          }
String                { return KW_STRING;          }
System\.out\.print    { return SYSTEM_OUT_PRINT;   }
System\.out\.println  { return SYSTEM_OUT_PRINTLN; }
Integer\.parseInt     { return INTEGER_PARSEINT;   }
void                  { return KW_VOID;            }
return                { return KW_RETURN;          }
if                    { return KW_IF;              }
else                  { return KW_ELSE;            }
while                 { return KW_WHILE;           }
new                   { return KW_NEW;             }
length                { return KW_LENGTH;          }
private               { return KW_PRIVATE;         }

"&&"                  { return TOK_AND;    } /* operators */
"||"                  { return TOK_OR;     }
"!="                  { return TOK_NEQ;    }
">"                   { return *yytext;    }
"<"                   { return *yytext;    }
">="                  { return TOK_GTE;    }
"<="                  { return TOK_LTE;    }
"=="                  { return TOK_EQ;     }
"+"                   { return *yytext;    }
"-"                   { return *yytext;    }
"*"                   { return *yytext;    }
"/"                   { return *yytext;    }
"!"                   { return *yytext;    }

"."                   { return *yytext; } /* single characters */
";"                   { return *yytext; }
"("                   { return *yytext; }
")"                   { return *yytext; }
"{"                   { return *yytext; }
"}"                   { return *yytext; }
","                   { return *yytext; }
"="                   { return *yytext; }
"["                   { return *yytext; }
"]"                   { return *yytext; }




[0-9]+ {
    yylval.integer = atoi(strdup(yytext));
    return INTEGER_LITERAL;
}

[a-zA-Z][a-zA-Z0-9_]* {
    yylval.string = strdup(yytext);
    return ID;                 
}

\"([^"\\]|\\.)*\" {
    yylval.string = strdup(yytext);
    return STRING_LITERAL;                    
}

.                           { syntax_error(); }                                 /* all other characters */
"++"                        { syntax_error(); }
"--"                        { syntax_error(); }

%%

int yywrap(void) {
    return 1;
}